LRU 

虚表：
	在C++语言中，每个有虚函数的类或者虚继承的子类，编译器都会为它生成一个虚拟函数表（简称：虚表），表中的每一个元素都指向一个虚函数的地址。（注意：虚表是从属于类的）
	此外，编译器会为包含虚函数的类加上一个成员变量，是一个指向该虚函数表的指针（常被称为vptr），每一个由此类别派生出来的类，都有这么一个vptr。虚表指针是从属于对象的。也就是说，如果一个类含有虚表，则该类的所有对象都会含有一个虚表指针，并且该虚表指针指向同一个虚表。
	虚表的内容是依据类中的虚函数声明次序--填入函数指针。派生类别会继承基础类别的虚表（以及所有其他可以继承的成员），当我们在派生类中改写虚函数时，虚表就受了影响；表中的元素所指的函数地址将不再是基类的函数地址，而是派生类的函数地址。
	如果一个类含有虚表，那么该类的所有对象都含有一个虚标指针，都指向这个虚表。

TCP的滑动窗口协议


TCP的阻塞控制

Java里的引用：

抽象类和接口的区别：
	可以多实现接口，只能单继承抽象类
	抽象类可以有构造器，接口不能
	
const修饰对象的时候，不能访问非const的函数，
const修饰函数的时候，不能修改数据成员

class aa{
    int num;
public:
    aa(){
        int b =10;
        num = b;
    };
    void out1(){
        cout<<num<<endl;
    }
    void out2() const{
        cout<<num<<endl;
    }
    void out3() const{
        num+=10; //出错，const函数不能修改其数据成员
        cout<<num<<endl;
    }

};
int main()
{
    aa a1;
    a1.out1();
    a1.out2();
    a1.out3();
    const aa a2;
    //a2.out1(); // 错误，const的成员 不能访问非const的函数
    a2.out2();
    a2.out3();
    return 0;
}

父类中的静态方法不能被子类所重写，重写只适用于实例方法。子类的静态方法与父类相同的话称之为隐藏
 


静态变量

#define 和 const 区别 

const 修饰




hashmap不安全，是因为：
hashMap在并发执行put操作的时候会引起死循环，导致cpu利用率100%，因为多线程导致hashMap的Node链表形成环形数据结构，一旦形成环形数据结构，Node的next一直不为空，就会在获取Node的时候产生死循环。

hashTable安全，效率低，因为在put和get都加上了synchronized

concurrentHashMap线程安全而且效率高，因为它包含了一个segment数组，对数据分段存储，给每一段数据加锁，，即锁分段技术。
Java8之后采用的cas算法：

hashmap的自动扩容：数组大小默认16，当检测元素个数超过数组大小*loadFactor之后，数组大小 *=2；

如何安全地使用hashMap:

1.synchronizedHashMap:   Map<String,string>  map = Collections.synchronizedHashMap(new HashMap<String,String>())

2.hashTable

3.ConcurrentHashMap


java虚拟机如何判定两个Java类是相同的：看类的全名以及加载此类的类加载器是否相同。

类加载器：类加载器负责读取Java字节代码，并转换为java.lang.Class的一个实例

加载：找到.class文件并把这个文件包含的字节码加载到内存中

连接：
	验证:验证被加载的类的正确性，字节码验证等
	准备：为静态变量分配内存，并将其初始化成默认值
	解析：将类中的符号引用转换成直接引用
初始化：类中的静态属性和初始化赋值，以及静态块的执行




Jvm:
	类加载器：在jvm启动或者类运行的时候将需要的class加载到jvm中
	执行引擎：负责执行class文件中的字节码指令，相当于jvm的cpu
	内存区：
		将内存划分成活干个区以模拟实际机器上的存储，记录和调度功能模块。
		方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
		运行时常量池：方法区的一部分，存放编译器生成的各个字面量和符号引用
		堆内存（线程共享）：所有线程共享的一块区域，垃圾回收器管理的主要区域。主要的垃圾回收算法是：分代回收算法。
		程序计数器：Java线程私有，记录程序的地址
		虚拟机栈（栈内存）：Java线程私有，描述Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。
 		本地方法栈：和Java虚拟机栈作用类似，区别是此区域采用的是native方法。
	本地方法调用：调用c/c++实现的本地方法的代码返回结果



GC：
	对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机hi行一次Minor GC
	大对象直接进入老年区（大对象时指需要大量连续内存空间的对象），避免在Eden区和两个survivor区之间发生大量的内存拷贝（新生区）
	老年代

static的用法：
	static的作用主要有两种:

	第一个作用是限定作用域；第二个作用是保持变量内容持久化；

	c语言中static的用法：
	
	static的作用主要有两种:

第一个作用是限定作用域；第二个作用是保持变量内容持久化；

c语言中static的用法：

1、全局静态变量：

　　用法：在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。 static int temp；

　　内存中的位置：静态存储区，在整个程序运行期间一直存在。

　　初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

　　作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

2、局部静态变量：

　　在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

　　内存中的位置：静态存储区

　　初始化：作用域还是在当前函数里边，只在函数初次定义或者声明的时候进行初始化，如果没有初始化值为0

　　作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

	void func()
	{
		static int t = 10;
		t ++;
		cout << t << endl;
	}

	int main()
	{
		func();
		func();
		func();
		return 0;
	}

	// output
	//11
	//12
	//13
3、静态函数：

　　在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用；

make file

tcp滑动窗口：
	

DNS的解析：
	一、主机解析域名的顺序

　　	1、找缓存

　　	2、找本机的hosts文件

　　	3、找DNS服务器


系统和应用：



TCP报文格式：





多文件全局：


路由转发：






批量向数据库中导入数据：


TCP的滑动窗口协议：


linux上配置服务器：DHCP 协议


TCP的阻塞控制：
	慢开始：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。
			当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以一次传输轮次之后拥塞窗口就加倍。这就是乘法增长，和后面的拥塞避免算法的加法增长比较。

			为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：

			当cwnd<ssthresh时，使用慢开始算法。

			当cwnd>ssthresh时，改用拥塞避免算法。

			当cwnd=ssthresh时，慢开始与拥塞避免算法任意。

	阻塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长
	
	快重传：发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期
	快恢复：
		①当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。
		②考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。
		所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

		
操作系统相关：
	大型网站，比如门户网站，在面对大量用户访问、高并发请求方面，
	基本的解决方案集中在这样几个环节：使用高性能的服务器、高性能的数据库、高效率的编程语言、还有高性能的Web容器。
			
		1、html静态化
		2、图片服务器分离：图片是最消耗资源的，于是我们有必要将图片与页面进行分离，这是基本上大型网站都会采用的策略，他们都有独立的、甚至很多台的图片服务器。
		3、数据库集群、库表散列
		4、缓存
		5、负载均衡：如硬件四层交换、软件四层交换
		6、采用CDN加速方式:
　　		采用了GCDN加速方式以后，系统会在浏览用户和您的服务器之间增加一台GCDN服务器。浏览用户访问您的服务器时，一般静态数据，如图片、多媒体资料等数据将直接从GCDN服务器读取，使得从主服务器上读取静态数据的交换量大大减少。
	
Java的反射：



构造函数和析构函数可以是虚函数吗？
	答案是构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。
		首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。
		而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。
		那么在构造函数完成之前，vptr是没有值的，也就无法通过vptr找到作为虚函数的构造函数所在的代码区，所以构造函数只能作为普通函数存放在类所指定的代码区中。
	那么为什么析构函数推荐最好设置为虚函数呢？
		当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。
		而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当时是希望可以调用派生类的析构函数对新定义的成员也进行析构啦。
面向对象编程：
	一个对象引用另一个对象
	
组合和聚合：
	聚合：表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。公司和员工的关系
	组合：整体和部分是强依赖的，整体不存在了部分也不存在了。公司和部门的关系

	
什么时候使用抽象类和接口
	如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。
	如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
	如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。
	

	
c/c++的堆栈：
	堆：
		1、申请内存：只要栈的剩余空间大于所申请空间，系统用将为程序提供内存，否则报异常提示栈溢出。
		2、内存由系统自动分配，熟读较快。但是程序员无法控制。
		3、申请大小的限制：是低地址扩展的数据结构，是一块连续的内存的区域，栈顶的地址和最大容量都是系统预先规定好的。
		
	堆：
		1、是向高地址扩展的数据结构，是不连续的内存区域。用链表来存储空闲内存地址，堆的大小受限于计算机系统中的有效的虚拟内存。
		2、有一个记录空闲内存地址的链表，当系统收到程序的申请时，会便利该链表，寻找第一个空间大于所申请空间的堆。
		3、是手动申请内存，一般速度比较慢，而且容易产生碎片，不过用起来很方便。
	

	
c/c++怎么清空内存的开辟：
	
筛选出sql：
	select name,count(*) from A group by name order by count(*) limit 3
	
join :
	select * from A join B on A.id = B.id ;


java的内存查看，内存泄露


vim中查找一个单词出现了多少次
	%s/word//ng
	
	
1M = 1024kb = 1024 * 1024 b(字节)·



1、获取Class对象的三种方式
1.1 Object ——> getClass();
1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性
1.3 通过Class类的静态方法：forName（String  className）(常用)
package fanshe;  
/** 
 * 获取Class对象的三种方式 
 * 1 Object ——> getClass(); 
 * 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 
 * 3 通过Class类的静态方法：forName（String  className）(常用) 
 * 
 */  
public class Fanshe {  
    public static void main(String[] args) {  
        //第一种方式获取Class对象    
        Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。  
        Class stuClass = stu1.getClass();//获取Class对象  
        System.out.println(stuClass.getName());  
          
        //第二种方式获取Class对象  
        Class stuClass2 = Student.class;  
        System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个  
          
        //第三种方式获取Class对象  
        try {  
            Class stuClass3 = Class.forName("fanshe.Student");//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名  
            System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象  
        } catch (ClassNotFoundException e) {  
            e.printStackTrace();  
        }  
          
    }  
}


const和define的区别
	const 定义的常数是变量 也带类型， #define 定义的只是个常数 不带类型
	define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。
	define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。
		#define N 2+3 //我们预想的N值是5，我们这样使用N
		double a = N/2;  //我们预想的a的值是2.5，可实际上a的值是3.5
	const不足的地方，是与生俱来的，const不能重定义，而#define可以通过#undef取消某个符号的定义，再重新定义。

	
多态：
	多态存在的三个条件
		1、有继承关系　　
		2、子类重写父类方法　　
		3、父类引用指向子类对象


进程的状态:
	

阻塞的怎么产生


进程的同步方式：

c++虚函数
https://blog.csdn.net/zzwdkxx/article/details/53635173